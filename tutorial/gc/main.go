// Есть физическая память
// в 64 разрядных машинах используется 48, 42 линии адреса, что позволяет иметь память в размере 256 ТБ ф.п.
// (каждая линия адреса указывает на конкретный бит в байте) 2^32 = 4 GB  2^64 = 16 эксабайт
//
// есть виртуальная память
// она ничего не хранит, ее задача соединить процесс - работающую программу с физической памятью.
// Виртуальная память представлена страницами памяти по 4 КБ
//
// Процессы видят лишь адреса виртуальной памяти.
// Память выделяемая для процесса, называется кучей (heap memory)
// Увеличение кучи (для процесса) происходит через системный вызов к ядру
//
// TCMalloc средство для выделения памяти процессам в языке golang
// идея разделения памяти на несколько уровней (размерность) ради уменьшения фрагментации памяти.
// Управление памятью делится на две части: работа с памятью потоков и работа с кучей.
// Когда для размещения в памяти (потоков) маленьких объектов места не хватает, за памятью обращаются к куче. Если и в куче недостаточно свободной памяти — дополнительная память запрашивается у операционной системы.
//
// MSPAN - блок памяти (минимальный размер 4 kb, 8 kb для ГО)
// (последовательность страниц виртуальной памяти)
// Представляет собой объект, который содержит:
// начальный адрес страницы,
// сведения о размере страницы
// и количество страниц, входящих в него.
//
// MCACHE - локальный кэш для потоков
// (память потока - процесса) управляет MSPAN
// на каждом логическом процессоре в один момент времени всегда работает одна горутина
// каждый логический процессор имеет свой собственный MCACHE
// поэтому выделение памяти (для маленьких объектов < 32 KB) в рамках MCACHE происходит очень быстро, без блокировок
//
// MCENTRAL - справочник диапазонов MSPAN определенного класса размера
// 1 содержит список занятых MSPAN
// 2 содержит список свободных MSPAN
// Когда памяти не хватает в MCACHE он обращается к MCENTRAL за получением свободных MSPAN
// Необходима блокировка на уровне отдельного MCENTRAL.
// Так как все MCENTRAL общие и доступны для всех процессоров (потоков, процессов)
// Но таким образом другая горутина может беспрепятственно запрашивать свободную память у другого MCENTRAL (если нужен другой размер)
//
// MHEAP - единственный объект который управляет кучей (общая свободная виртуальная память).
// Содержит в себе все MCENTRAL
// Когда памяти в куче не хватает, идет блокировка на уровне MHEAP. И MHEAP запрашиват дополнительную память у ОС
// Таким образом в один момент времени только одна горутина может делать такой запрос. Остальные ждут.
// Также идет блокировка на уровне MHEAP когда памяти хватает, но идет работа с большими объектами > 32 KB
//
// ЧИСЛА
// 32 > x		MCACHE
// 32 < x		MCENTRAL
// 32 < x		MHEAP
//
// Арена = 64 МБ
// Куча это набор арен
//
// go build -gcflags=-m
// показывает куда будут аллоцированы переменные программы
package main

import (
	"fmt"
	"time"
)

const (
	_         = iota
	KB uint64 = 1 << (10 * iota) // тысяча
	MB                           // миллион
	GB                           // миллиард
	TB                           // триллион
	PB                           // квадриллион
	EB                           // квинтиллион
)

var ballast []byte

// ps -ao pmem,comm,pid,maj_flt,min_flt,rss,vsz --sort -rss | numfmt --header --to=iec --field 4-5 | numfmt --header --from-unit=1024 --to=iec --field 6-7 | column -t
// VSZ выделенная виртуальная память
// RSS выделенная физическая память
func main() {

	// Create a large heap allocation of ~700 MiB
	ballast = make([]byte, MB)
	fmt.Println(len(ballast))

	// for i := 0; i < len(ballast)/2; i++ {
	// 	ballast[i] = byte('A')
	// }

	// блокировка (процессоры отдыхают)
	<-time.After(time.Hour)

	// печка (печём блины на процессоре)
	// for {
	// }
}
