// Каналы, это объект через который можно обеспечить взаимодействие нескольких горутин
// В объявлении каналов можно указать их направленность. Только для чтения "<-chan" или только для записи "chan<-"

// gorutine - облегченный отдельный поток (это функция или метод запускаемая как отдельная программа)
// gorutine - не зависимо выполняемая логическая часть программы запущенная оператором go
// gorutine - обертка над тредом (тредом управляет ОС, gorutine управляет runtime)
// runtime занимается распределением горутин по тредам
// memory from one gorutine 2 KB

// deadlock это когда мы бесконечно ждем чтения из канала и не можем прочитать (в канал никто не пишет)
// или наоборот бесконечно пишем в канал который никто не будет читать.
// Также это происходит когда производиться чтение или запись в не инициализированный канал
// Это справедливо в работе основной программы. В порожденных (дочерних) горутинах в таких ситуациях дедлока не будет.
// Так порождаются зомбо процессы. )))

// race или состояние гонки это конфликтный (одновременный) доступ к общим данным из разных горутин
// Не общайтесь, разделяя память. Вместо этого делитесь памятью, общаясь через каналы.
// антоним race согласованность

// go run -race test.go (аргумент race) дает информацию о взаимодействии горутин с общими объектами
// с его помощью можно тестировать отдельный участки программы работающие с горутинами на предмет дедлоков и гонок

// range блокируется пока не получит из канала значение (работает) либо канал не будет закрыт (выходит из цикла)
// select без default блокируются пока не получит из канала значение либо получает пустое значение если канал закрыт
// Аналогичным образом работает логический оператор If. if val, ok := ←ch; ok {...}
// смотри пример select2
// закрытие канала нужно проверять (val, ok := <-ch)
// закрытый канал можно читать но в него нельзя писать

// concurrency поочередная работа нескольких горутин на одном ядре
// параллелизм параллельная работа горутин на нескольких ядрах
package main

import (
	"fmt"
)

// пример гонок
// go run -race ./doc.go
func main() {
	c := make(chan bool)
	m := make(map[string]string)
	go func() {
		m["1"] = "a" // First conflicting access.
		c <- true
	}()
	m["2"] = "b" // Second conflicting access.
	<-c
	for k, v := range m {
		fmt.Println(k, v)
	}
}
