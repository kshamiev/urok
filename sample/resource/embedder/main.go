package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"text/template"
	"time"

	"github.com/webnice/dic"
)

const tpl = `// This file generated by go generate; DO NOT EDIT.
// НЕ РЕДАКТИРОВАТЬ! Изменения будут перезаписаны при следующей генерации.

package {{ .pkg }}

import "time"

func init() {
	_ = Get().Add(
		"{{ .group }}",
		"{{ .info.Name }}",
		Resource{
			Size: {{ .info.Size }},
			Time: func() time.Time {
				t, _ := time.ParseInLocation(time.RFC3339Nano, "{{ .info.Time.Format .info.TimeFormat }}", time.Local)
				return t
			}(),
			ContentType: "{{ .info.ContentType }}",
			Content: []byte{
				{{ .info.Content }},
			},
		})
}
`

var (
	templateEmbed      = template.Must(template.New("").Parse(tpl))
	rexResourcePattern = regexp.MustCompile(`(?mi)^resource_.+_\d{20}\.go`)
)

type (
	configuration struct {
		Package string                   // Название пакета.
		Path    string                   // Директория размещения создаваемых файлов.
		Sources map[string]resourceGroup // Встраиваемые ресурсы.
	}
	resourceGroup struct {
		Path string         // Базовая директория группы ресурсов.
		File []resourceInfo // Файлы ресурсов с информацией о ресурсах.
	}
	resourceInfo struct {
		Size        int64            // Размер ресурса в байтах.
		Time        time.Time        // Дата и время создания ресурса.
		TimeFormat  string           // Формат времени. По умолчанию time.RFC3339Nano.
		Name        string           // Название ресурса. Путь и имя файла относительно базовой директории.
		ContentType string           // Определённый по расширению имени файла тип контента ресурса.
		Content     *strings.Builder // Преобразованный под шаблонизатор, контент файла.
	}
)

func main() {
	const (
		errArg             = "Ошибка загрузки исходных параметров: %s."
		errResourceList    = "Ошибка получения списка ресурсов: %s."
		errResourceContent = "Ошибка удаления старых ресурсов: %s."
		errResourceCreate  = "Ошибка создания ресурсов: %s."
	)
	var (
		cfg *configuration
		err error
	)

	// Получение аргументов.
	if cfg, err = getArg(); err != nil {
		log.Fatalf(errArg, err)
	}
	// Получение списка ресурсов.
	if err = getResourceList(cfg); err != nil {
		log.Fatalf(errResourceList, err)
	}
	// Удаление старых ресурсов.
	if err = cleanResourceContent(cfg); err != nil {
		log.Fatalf(errResourceContent, err)
		return
	}
	// Создание новых ресурсов.
	if err = makeResourceContent(cfg); err != nil {
		log.Fatalf(errResourceCreate, err)
		return
	}
}

// Загрузка конфигурации из аргументов командной строки и переменных окружения.
func getArg() (*configuration, error) {
	abs := func(wd, p string) string {
		if p == "" || (p != "" && p[0] != '/') {
			p = path.Join(wd, p)
		}
		return p
	}
	_, filePath, _, _ := runtime.Caller(0)
	filePath = path.Dir(path.Dir(filePath))
	cfg := &configuration{
		Package: path.Base(filePath),
		Path:    filePath,
		Sources: make(map[string]resourceGroup),
	}
	workDir, err := os.Getwd()
	if err != nil {
		return nil, fmt.Errorf("ошибка получения текущей директории: %w", err)
	}
	src := strings.Split(os.Getenv("EMBED_STATIC_RESOURCES"), ",")
	for n := range src {
		tmp := strings.Split(src[n], ":") // tmp[0] - группа, tmp[1] - папка с файлами
		if len(tmp) != 2 {
			continue
		}
		cfg.Sources[strings.ToLower(tmp[0])] = resourceGroup{Path: abs(workDir, tmp[1])}
	}
	return cfg, nil
}

// Получение списка всех файлов ресурсов с необходимыми атрибутами.
func getResourceList(cfg *configuration) (err error) {
	var (
		group string
		info  []resourceInfo
	)

	for group = range cfg.Sources {
		if info, err = getSourceInfo(cfg.Sources[group].Path, ""); err != nil {
			return
		}
		cfg.Sources[group] = resourceGroup{
			Path: cfg.Sources[group].Path,
			File: info,
		}
	}

	return
}

// Рекурсивное получение списка ресурсов с атрибутами для одной группы ресурсов.
func getSourceInfo(base, p string) (ret []resourceInfo, err error) {
	const (
		limitSize    = 100000000
		errReadDir   = "чтение директории %q прервано ошибкой: %w"
		errMime      = "неизвестный тип контента, расширение имени файла %q"
		errLimitSize = "Файл %q пропущен, размер файла %d, больше лимита %d байт."
	)
	var (
		fid    []os.DirEntry
		fi     os.FileInfo
		inf    []resourceInfo
		n      int
		dn, fn string
		buf    []byte
		mime   dic.IMime
	)

	dn = path.Join(base, p)
	if fid, err = os.ReadDir(dn); err != nil {
		err = fmt.Errorf(errReadDir, dn, err)
		return
	}
	for n = range fid {
		if fid[n].IsDir() {
			if inf, err = getSourceInfo(base, path.Join(p, fid[n].Name())); err != nil {
				return
			}
			ret = append(ret, inf...)
			continue
		}
		if fi, err = fid[n].Info(); err != nil {
			err = nil
			continue
		}

		if fi.Size() == 0 {
			continue
		}
		fn = path.Join(base, p, fid[n].Name())
		if buf, err = getFileContent(fn); err != nil {
			return
		}
		if mime = dic.File().MimeByFilename(fn); mime == nil {
			mime = dic.File().MimeByContent(buf)
		}
		if mime == nil {
			err = fmt.Errorf(errMime, filepath.Ext(fn))
			return
		}
		if fi.Size() > limitSize {
			log.Printf(errLimitSize, fn, fi.Size(), limitSize)
			continue
		}
		ret = append(ret, resourceInfo{
			Size:        fi.Size(),
			Time:        fi.ModTime(),
			TimeFormat:  time.RFC3339Nano,
			Name:        path.Join(p, fid[n].Name()),
			ContentType: mime.String(),
			Content:     getSliceOfBytesAsString(buf),
		})
	}

	return
}

// Загрузка всего контента файла.
func getFileContent(fn string) (ret []byte, err error) {
	const errReadAll = "чтение файла %q прервано ошибкой: %w"
	var fh *os.File

	if fh, err = os.Open(fn); err != nil {
		return
	}
	defer func() { _ = fh.Close() }()
	if ret, err = io.ReadAll(fh); err != nil {
		err = fmt.Errorf(errReadAll, fn, err)
		return
	}

	return
}

// Преобразование среза байт в строку для golang со срезом байт.
func getSliceOfBytesAsString(data []byte) (ret *strings.Builder) {
	const delimiter, newLine, lineWidth = ", ", "\n", 24
	var (
		b byte
		n int
	)

	ret = new(strings.Builder)
	for _, b = range data {
		if ret.Len() > 0 {
			ret.WriteString(delimiter)
		}
		if n >= lineWidth {
			n = 0
			ret.WriteString(newLine)
		}
		_, _ = fmt.Fprintf(ret, "0x%02x", int(b))
		n++
	}

	return
}

// Удаление старых ресурсов.
func cleanResourceContent(cfg *configuration) (err error) {
	const (
		errReadDir = "чтение директории %q прервано ошибкой: %w"
		errRemove  = "удаление старого файла ресурса %q прервано ошибкой: %w"
	)
	var (
		fid []fs.DirEntry
		n   int
	)

	if fid, err = os.ReadDir(cfg.Path); err != nil {
		err = fmt.Errorf(errReadDir, cfg.Path, err)
		return
	}
	for n = range fid {
		if fid[n].IsDir() {
			continue
		}
		if !rexResourcePattern.MatchString(fid[n].Name()) {
			continue
		}
		if err = os.Remove(path.Join(cfg.Path, fid[n].Name())); err != nil {
			err = fmt.Errorf(errRemove, fid[n].Name(), err)
			return
		}
	}

	return
}

// Создание новых ресурсов.
func makeResourceContent(cfg *configuration) (err error) {
	const (
		errTemplate = "обработка шаблона прервана ошибкой: %w"
		errFormat   = "форматирование созданного .go файла прервана ошибкой: %w"
		logCreated  = "+Создан ресурс: %s:%s, размер: %d байт."
	)
	var (
		buf       *bytes.Buffer
		data      []byte
		groupName string
		n         int
		info      resourceInfo
		vars      map[string]interface{}
	)

	for groupName = range cfg.Sources {
		for n = range cfg.Sources[groupName].File {
			info = cfg.Sources[groupName].File[n]
			vars = make(map[string]interface{})
			vars["pkg"] = cfg.Package
			vars["group"] = groupName
			vars["info"] = info
			buf = &bytes.Buffer{}
			if err = templateEmbed.Execute(buf, vars); err != nil {
				err = fmt.Errorf(errTemplate, err)
				return
			}
			if data, err = format.Source(buf.Bytes()); err != nil {
				err = fmt.Errorf(errFormat, err)
				return
			}
			if err = saveFile(cfg.Path, groupName, int64(n+1), data); err != nil {
				return
			}
			log.Printf(logCreated, groupName, info.Name, info.Size)
			info.Content.Reset()
			info.Content = nil
		}
	}

	return
}

// Сохранение созданного файла с ресурсом.
func saveFile(dir, group string, number int64, data []byte) (err error) {
	const (
		defaultFileMode = os.FileMode(0o644)
		fnTemplate      = "resource_%s_%020d.go"
		errWriteFile    = "создание файла %q прервано ошибкой: %w"
	)
	var fn string

	fn = fmt.Sprintf(fnTemplate, group, number)
	fn = path.Join(dir, fn)
	if err = os.WriteFile(fn, data, defaultFileMode); err != nil {
		err = fmt.Errorf(errWriteFile, fn, err)
		return
	}

	return
}
