searchd {
  listen = 127.0.0.1:9312
  listen = 127.0.0.1:9306:mysql
  listen = 127.0.0.1:9308:http
  listen = 127.0.0.1:9322-9325:replication
  query_log_format = sphinxql
  query_log = /var/log/manticore/query.log
  log = /var/log/manticore/searchd.log
  pid_file = /var/run/manticore/searchd.pid
  network_timeout = 1m
}

common {
  plugin_dir = /usr/local/lib/manticore
}

#index users_breaker {
#  type = rt
#  path = /var/lib/manticore/users_breaker
#  rt_attr_string = index_name
#  rt_attr_timestamp = updated_at
#}


source users_main {
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = postgres
  sql_db = urok
  sql_port = 5432


  sql_query_pre = INSERT INTO users_breaker (id, index_name, updated_at) \
  VALUES (1, 'users_main', now()) \
  ON CONFLICT (id) DO UPDATE SET \
  index_name = EXCLUDED.index_name, updated_at = EXCLUDED.updated_at;

  sql_query_range = SELECT \
  ( SELECT extract(epoch from MIN(updated_at)::timestamptz) FROM films ) min, \
  ( SELECT extract(epoch from updated_at::timestamptz) FROM users_breaker WHERE index_name = 'users_main') max

  sql_range_step = 1000

  sql_query = SELECT \
  id, title, description, category_id, release_year, price, created_at, updated_at, deleted_at \
  FROM films \
  WHERE deleted_at IS NULL \
  AND updated_at >= to_timestamp($start) AND updated_at < to_timestamp($end)

  sql_query_post_index = INSERT INTO users_breaker (id, index_name, updated_at) \
  VALUES (2, 'users_delta', (SELECT updated_at FROM users_breaker WHERE index_name = 'users_main')) \
  ON CONFLICT (id) DO UPDATE SET \
  index_name = EXCLUDED.index_name, updated_at = EXCLUDED.updated_at;

  # sql_attr_bigint = id
  # sql_field_string = title
  # sql_field_string = description
  # sql_attr_float = price
}

index users_main_idx {
  type = plain
  path = /var/lib/manticore/users_main_idx
  source = users_main
}
