searchd {
  listen = 127.0.0.1:9312
  listen = 127.0.0.1:9306:mysql
  listen = 127.0.0.1:9308:http
  listen = 127.0.0.1:9322-9325:replication
  query_log_format = sphinxql
  query_log = /var/log/manticore/query.log
  log = /var/log/manticore/searchd.log
  pid_file = /var/run/manticore/searchd.pid
  network_timeout = 1m
  read_buffer_docs = 512m
  read_buffer_hits = 512m
  read_unhinted = 512m
  max_packet_size = 128m
  max_open_files = 100000
  max_batch_queries = 102400
  docstore_cache_size = 1024m
  threads = 50
}

common {
  plugin_dir = /usr/local/lib/manticore
  lemmatizer_base = /usr/share/manticore
}

indexer {
  mem_limit = 1024M
}

source users_main {
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = postgres
  sql_db = urok
  sql_port = 5432

  sql_query_pre = INSERT INTO manticore_breaker (index_name, updated_at) \
  VALUES ('users_main', now()) \
  ON CONFLICT (index_name) DO UPDATE SET updated_at = EXCLUDED.updated_at

  sql_query_range = SELECT \
  ( SELECT extract(epoch from MIN(updated_at)::timestamptz) FROM films ) min, \
  ( SELECT extract(epoch from updated_at::timestamptz) FROM manticore_breaker WHERE index_name = 'users_main') max

  sql_range_step = 100000
  sql_ranged_throttle = 0

  sql_query = SELECT \
  id, title, description, category_id, release_year, price, created_at, updated_at, deleted_at \
  FROM films \
  WHERE 1 = 1 \
  AND deleted_at IS NULL AND updated_at BETWEEN to_timestamp($start) AND to_timestamp($end)

  sql_query_post_index = INSERT INTO manticore_breaker (index_name, updated_at, max_id, date_finish) \
  VALUES ('users_delta', (SELECT updated_at FROM manticore_breaker WHERE index_name = 'users_main'), $maxid, now()) \
  ON CONFLICT (index_name) DO UPDATE SET updated_at = EXCLUDED.updated_at;

  # sql_attr_bigint = id
  # sql_field_string = title
  # sql_field_string = description
  # sql_attr_float = price
}

index users_main {
  type = plain
  path = /var/lib/manticore/users_main
  source = users_main

  min_stemming_len = 4 # Минимальная длина слова, при которой можно включить выделение корней (не менее).
  index_sp = 1  # учитывать границы абзацев
  html_strip = 1 # учитывать границы абзацев (html)
  index_exact_words = 1 # сохраняет необработанные ключевые слова в индекс (повышает релевантность поиска)
  stopwords = en ru # стоп слова
  morphology = lemmatize_ru_all # расширенная морфология
}

source users_delta: users_main {
  sql_query_pre =

  sql_query_range = SELECT \
  ( SELECT extract(epoch from updated_at::timestamptz) FROM manticore_breaker WHERE index_name = 'users_delta') min, \
  extract(epoch from now()::timestamptz) max

  sql_query_killlist = SELECT id FROM films \
  WHERE updated_at >= (SELECT updated_at FROM manticore_breaker WHERE index_name = 'users_delta')

  sql_query_post_index =

  # sql_attr_bigint = id
  # sql_field_string = title
  # sql_field_string = description
  # sql_attr_float = price
}

index users_delta: users_main {
  type = plain
  path = /var/lib/manticore/users_delta
  source = users_delta
  killlist_target = users_main:kl
}

index users {
  type = distributed
  local = users_main
  local = users_delta
}
